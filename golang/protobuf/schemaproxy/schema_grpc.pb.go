// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package schemaproxy

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// SchemaProxyServiceClient is the client API for SchemaProxyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SchemaProxyServiceClient interface {
	RegisterSchema(ctx context.Context, in *RegisterSchemaRequest, opts ...grpc.CallOption) (*RegistryResponse, error)
	DeleteSubject(ctx context.Context, in *DeleteSubjectRequest, opts ...grpc.CallOption) (*DeleteSubjectResponse, error)
	CheckSchemaCompatibility(ctx context.Context, in *CheckSchemaCompatibilityRequest, opts ...grpc.CallOption) (*CheckSchemaCompatibilityResponse, error)
	GetSubjectVersions(ctx context.Context, in *GetSubjectVersionsRequest, opts ...grpc.CallOption) (*GetSubjectVersionsResponse, error)
	GetSchemas(ctx context.Context, in *GetSchemasRequest, opts ...grpc.CallOption) (*GetSchemasResponse, error)
	UpdateCompatibility(ctx context.Context, in *UpdateCompatibilityRequest, opts ...grpc.CallOption) (*UpdateCompatibilityResponse, error)
	Test(ctx context.Context, in *TestRequest, opts ...grpc.CallOption) (*TestResponse, error)
}

type schemaProxyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSchemaProxyServiceClient(cc grpc.ClientConnInterface) SchemaProxyServiceClient {
	return &schemaProxyServiceClient{cc}
}

func (c *schemaProxyServiceClient) RegisterSchema(ctx context.Context, in *RegisterSchemaRequest, opts ...grpc.CallOption) (*RegistryResponse, error) {
	out := new(RegistryResponse)
	err := c.cc.Invoke(ctx, "/hlidskjalf.schemaproxy.SchemaProxyService/RegisterSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaProxyServiceClient) DeleteSubject(ctx context.Context, in *DeleteSubjectRequest, opts ...grpc.CallOption) (*DeleteSubjectResponse, error) {
	out := new(DeleteSubjectResponse)
	err := c.cc.Invoke(ctx, "/hlidskjalf.schemaproxy.SchemaProxyService/DeleteSubject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaProxyServiceClient) CheckSchemaCompatibility(ctx context.Context, in *CheckSchemaCompatibilityRequest, opts ...grpc.CallOption) (*CheckSchemaCompatibilityResponse, error) {
	out := new(CheckSchemaCompatibilityResponse)
	err := c.cc.Invoke(ctx, "/hlidskjalf.schemaproxy.SchemaProxyService/CheckSchemaCompatibility", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaProxyServiceClient) GetSubjectVersions(ctx context.Context, in *GetSubjectVersionsRequest, opts ...grpc.CallOption) (*GetSubjectVersionsResponse, error) {
	out := new(GetSubjectVersionsResponse)
	err := c.cc.Invoke(ctx, "/hlidskjalf.schemaproxy.SchemaProxyService/GetSubjectVersions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaProxyServiceClient) GetSchemas(ctx context.Context, in *GetSchemasRequest, opts ...grpc.CallOption) (*GetSchemasResponse, error) {
	out := new(GetSchemasResponse)
	err := c.cc.Invoke(ctx, "/hlidskjalf.schemaproxy.SchemaProxyService/GetSchemas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaProxyServiceClient) UpdateCompatibility(ctx context.Context, in *UpdateCompatibilityRequest, opts ...grpc.CallOption) (*UpdateCompatibilityResponse, error) {
	out := new(UpdateCompatibilityResponse)
	err := c.cc.Invoke(ctx, "/hlidskjalf.schemaproxy.SchemaProxyService/UpdateCompatibility", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaProxyServiceClient) Test(ctx context.Context, in *TestRequest, opts ...grpc.CallOption) (*TestResponse, error) {
	out := new(TestResponse)
	err := c.cc.Invoke(ctx, "/hlidskjalf.schemaproxy.SchemaProxyService/Test", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchemaProxyServiceServer is the server API for SchemaProxyService service.
// All implementations must embed UnimplementedSchemaProxyServiceServer
// for forward compatibility
type SchemaProxyServiceServer interface {
	RegisterSchema(context.Context, *RegisterSchemaRequest) (*RegistryResponse, error)
	DeleteSubject(context.Context, *DeleteSubjectRequest) (*DeleteSubjectResponse, error)
	CheckSchemaCompatibility(context.Context, *CheckSchemaCompatibilityRequest) (*CheckSchemaCompatibilityResponse, error)
	GetSubjectVersions(context.Context, *GetSubjectVersionsRequest) (*GetSubjectVersionsResponse, error)
	GetSchemas(context.Context, *GetSchemasRequest) (*GetSchemasResponse, error)
	UpdateCompatibility(context.Context, *UpdateCompatibilityRequest) (*UpdateCompatibilityResponse, error)
	Test(context.Context, *TestRequest) (*TestResponse, error)
	mustEmbedUnimplementedSchemaProxyServiceServer()
}

// UnimplementedSchemaProxyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSchemaProxyServiceServer struct {
}

func (UnimplementedSchemaProxyServiceServer) RegisterSchema(context.Context, *RegisterSchemaRequest) (*RegistryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterSchema not implemented")
}
func (UnimplementedSchemaProxyServiceServer) DeleteSubject(context.Context, *DeleteSubjectRequest) (*DeleteSubjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSubject not implemented")
}
func (UnimplementedSchemaProxyServiceServer) CheckSchemaCompatibility(context.Context, *CheckSchemaCompatibilityRequest) (*CheckSchemaCompatibilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckSchemaCompatibility not implemented")
}
func (UnimplementedSchemaProxyServiceServer) GetSubjectVersions(context.Context, *GetSubjectVersionsRequest) (*GetSubjectVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubjectVersions not implemented")
}
func (UnimplementedSchemaProxyServiceServer) GetSchemas(context.Context, *GetSchemasRequest) (*GetSchemasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSchemas not implemented")
}
func (UnimplementedSchemaProxyServiceServer) UpdateCompatibility(context.Context, *UpdateCompatibilityRequest) (*UpdateCompatibilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCompatibility not implemented")
}
func (UnimplementedSchemaProxyServiceServer) Test(context.Context, *TestRequest) (*TestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Test not implemented")
}
func (UnimplementedSchemaProxyServiceServer) mustEmbedUnimplementedSchemaProxyServiceServer() {}

// UnsafeSchemaProxyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SchemaProxyServiceServer will
// result in compilation errors.
type UnsafeSchemaProxyServiceServer interface {
	mustEmbedUnimplementedSchemaProxyServiceServer()
}

func RegisterSchemaProxyServiceServer(s grpc.ServiceRegistrar, srv SchemaProxyServiceServer) {
	s.RegisterService(&_SchemaProxyService_serviceDesc, srv)
}

func _SchemaProxyService_RegisterSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaProxyServiceServer).RegisterSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hlidskjalf.schemaproxy.SchemaProxyService/RegisterSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaProxyServiceServer).RegisterSchema(ctx, req.(*RegisterSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaProxyService_DeleteSubject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSubjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaProxyServiceServer).DeleteSubject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hlidskjalf.schemaproxy.SchemaProxyService/DeleteSubject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaProxyServiceServer).DeleteSubject(ctx, req.(*DeleteSubjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaProxyService_CheckSchemaCompatibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckSchemaCompatibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaProxyServiceServer).CheckSchemaCompatibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hlidskjalf.schemaproxy.SchemaProxyService/CheckSchemaCompatibility",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaProxyServiceServer).CheckSchemaCompatibility(ctx, req.(*CheckSchemaCompatibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaProxyService_GetSubjectVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubjectVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaProxyServiceServer).GetSubjectVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hlidskjalf.schemaproxy.SchemaProxyService/GetSubjectVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaProxyServiceServer).GetSubjectVersions(ctx, req.(*GetSubjectVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaProxyService_GetSchemas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSchemasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaProxyServiceServer).GetSchemas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hlidskjalf.schemaproxy.SchemaProxyService/GetSchemas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaProxyServiceServer).GetSchemas(ctx, req.(*GetSchemasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaProxyService_UpdateCompatibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCompatibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaProxyServiceServer).UpdateCompatibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hlidskjalf.schemaproxy.SchemaProxyService/UpdateCompatibility",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaProxyServiceServer).UpdateCompatibility(ctx, req.(*UpdateCompatibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaProxyService_Test_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaProxyServiceServer).Test(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hlidskjalf.schemaproxy.SchemaProxyService/Test",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaProxyServiceServer).Test(ctx, req.(*TestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SchemaProxyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hlidskjalf.schemaproxy.SchemaProxyService",
	HandlerType: (*SchemaProxyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterSchema",
			Handler:    _SchemaProxyService_RegisterSchema_Handler,
		},
		{
			MethodName: "DeleteSubject",
			Handler:    _SchemaProxyService_DeleteSubject_Handler,
		},
		{
			MethodName: "CheckSchemaCompatibility",
			Handler:    _SchemaProxyService_CheckSchemaCompatibility_Handler,
		},
		{
			MethodName: "GetSubjectVersions",
			Handler:    _SchemaProxyService_GetSubjectVersions_Handler,
		},
		{
			MethodName: "GetSchemas",
			Handler:    _SchemaProxyService_GetSchemas_Handler,
		},
		{
			MethodName: "UpdateCompatibility",
			Handler:    _SchemaProxyService_UpdateCompatibility_Handler,
		},
		{
			MethodName: "Test",
			Handler:    _SchemaProxyService_Test_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "schemaproxy/schema.proto",
}
